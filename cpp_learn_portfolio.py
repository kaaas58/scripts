# =====================================================================
# C++ Learning Automator â€“ Hybrid Version
#
# Ebene wo steps liegen ist hardcodet auf ..\cpp_mastery\steps\
# VERWENDUNG:
#
# 1) UPDATE-MODUS (Screenshots & Thumbnails aktualisieren)
#      py cpp_learn_portfolio.py
#
#    â†’ Durchsucht alle Step-Ordner und:
#        â€¢ generiert fehlende Thumbnails (197px)
#        â€¢ aktualisiert Screenshot-Listen in allen READMEs
#        â€¢ sortiert chronologisch (neueste zuerst)
#
# 2) AUTO-INIT (Automatische Step-Nummer)
#      py cpp_learn.py Smart Pointers
#      py cpp_learn.py hallo wallo knallo
#
#    â†’ Findet automatisch die nÃ¤chste Step-Nummer und legt an:
#        â€¢ step_XX_smart-pointers/
#        â€¢ README.md mit Template
#        â€¢ CMakeLists.txt (funktionsfÃ¤hig)
#        â€¢ CMakePresets.json (VS Code ready)
#        â€¢ src/main.cpp (Hello World Template)
#        â€¢ build/ Ordner
#        â€¢ screenshots/ + thumbnails/ Ordner
#
# 3) MANUELL-INIT (Step selbst angeben)
#      py cpp_learn.py 05 Smart Pointers
#      py cpp_learn.py 03 hello world test
#
#    â†’ Legt Step mit gewÃ¼nschter Nummer an
#
# =====================================================================

import os
import sys
import re
from datetime import datetime

# Optional: PIL fÃ¼r Thumbnails
try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    print("âš ï¸  PIL nicht installiert. Thumbnails werden Ã¼bersprungen.")
    print("   Installation: pip install Pillow")

THUMB_WIDTH = 197
PER_PAGE = 25
LOGFILE = "update_log.txt"

# ORDNER: Eine Ebene hoch, dann cpp_mastery/steps/
ROOT_DIR = os.path.abspath(os.path.join(os.getcwd(), "..", "cpp_mastery"))
STEPS_DIR = os.path.join(ROOT_DIR, "steps")

# MinGW Pfad (anpassen falls nÃ¶tig)
MINGW_PATH = r"C:\Program Files\mingw64\bin"

# =====================================================================
# TEMPLATES
# =====================================================================

README_TEMPLATE = """
# Step {step} - {title}

![C++](https://img.shields.io/badge/C++-17%2F20-00599C?logo=cplusplus)
![Progress](https://img.shields.io/badge/Step-{step}-lightgreen)

## ğŸ“š Was ich gelernt habe

- Punkt 1
- Punkt 2
- ...

### Beispielcode

```cpp
{example_code}
```

## ğŸ› Was ich debugged habe

- Problem 1
- Problem 2
- ...

### Debug-Beispiel

```cpp
{debug_code}
```

## ğŸ’¡ Erkenntnisse & Notizen

-
-

## Struktur

```plaintext
step_XX_name/
â”œâ”€â”€ README.md
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ CMakePresets.json
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.cpp
â”‚
â”œâ”€â”€ include/
â”‚   â””â”€â”€ (optional header)
â”‚
â”œâ”€â”€ screenshots/
â”‚   â””â”€â”€ *.png
â”‚
â”œâ”€â”€ thumbnails/
â”‚   â””â”€â”€ *.png
â”‚
â”œâ”€â”€ build/               # CMake-Output â€“ wird NICHT eingecheckt
â”‚   â””â”€â”€ debug/
â”‚       â””â”€â”€ <exe>
â”‚
â””â”€â”€ .vscode/             # lokal generiert, wird NICHT eingecheckt
    â””â”€â”€ launch.json
```

## ğŸ“¸ Screenshots

{screenshots_markdown}
"""

CMAKELISTS_TEMPLATE = """# =====================================================
# Step {step}: {title}
# Auto-generated by cpp_learn.py
# =====================================================

cmake_minimum_required(VERSION 3.16)
project(step_{step}_{title_norm} LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Falls du spÃ¤ter include/ nutzt
include_directories(include)

# Alle .cpp Dateien in src/
file(GLOB SOURCES "src/*.cpp")

add_executable(step_{step}_{title_norm} ${{SOURCES}})
"""

def get_cmake_presets(step, title_norm):
    """Gibt CMakePresets.json als Dict zurÃ¼ck"""
    return {
        "version": 3,
        "configurePresets": [
            {
                "name": "default",
                "generator": "Ninja",
                "binaryDir": "${sourceDir}/build",
                "cacheVariables": {
                    "CMAKE_BUILD_TYPE": "Debug",
                    "CMAKE_C_COMPILER": f"{MINGW_PATH}/gcc.exe",
                    "CMAKE_CXX_COMPILER": f"{MINGW_PATH}/g++.exe"
                }
            }
        ],
        "buildPresets": [
            {
                "name": "default",
                "configurePreset": "default"
            }
        ]
    }

MAIN_CPP_TEMPLATE = """// =====================================================
// Step {step}: {title}
// =====================================================

#include <iostream>

int main() {{
    std::cout << "Step {step}: {title}" << std::endl;
    std::cout << "Hello, C++ Learning!" << std::endl;
    
    // Dein Code hier...
    
    return 0;
}}
"""

LAUNCH_JSON_TEMPLATE = """
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Launch Step",
            "type": "cppdbg",
            "request": "launch",

            // CMake Tools erzeugt immer die EXE im Preset build/
            "program": "${workspaceFolder}/build/${command:cmake.launchTargetPath}",

            "cwd": "${workspaceFolder}",
            "stopAtEntry": false,

            // MinGW + GDB
            "MIMode": "gdb",
            "miDebuggerPath": "C:/Program Files/mingw64/bin/gdb.exe",

            // Vor dem Debuggen automatisch bauen
            "preLaunchTask": "cmake.build",

            "console": "integratedTerminal"
        }
    ]
}
"""

GITIGNORE_TEMPLATE = """# =====================================================
# .gitignore fÃ¼r C++ Learning Project
# Auto-generated by cpp_learn.py
# =====================================================

# Build artifacts
**/build/*
!**/build/.gitkeep
**/*.exe
**/*.o
**/*.obj
**/*.a
**/*.lib
**/*.dll
**/*.so
**/*.dylib

# Auto-generated thumbnails
**/thumbnails/

# IDE/Editor
.vscode/
.vs/
*.swp
*.swo
*~
.idea/

# CMake
**/CMakeCache.txt
**/CMakeFiles/
**/cmake_install.cmake
**/Makefile

# Logs
**/update_log.txt
*.log

# OS
.DS_Store
Thumbs.db
"""

# =====================================================================
# Logging
# =====================================================================

def log(msg: str):
    """Schreibt Log-EintrÃ¤ge in update_log.txt"""
    log_path = os.path.join(os.getcwd(), LOGFILE)
    with open(log_path, "a", encoding="utf-8") as f:
        f.write(f"{datetime.now()} | {msg}\n")

# =====================================================================
# Thumbnail Generator
# =====================================================================

def create_thumbnail(input_path, output_path):
    """Erstellt ein Thumbnail aus einem Bild"""
    if not PIL_AVAILABLE:
        return False
    
    try:
        img = Image.open(input_path)
        img.thumbnail((THUMB_WIDTH, THUMB_WIDTH))
        img.save(output_path)
        return True
    except Exception as e:
        log(f"[ERROR] Konnte Thumbnail nicht erzeugen: {input_path} â†’ {e}")
        return False

# =====================================================================
# Update Screenshots fÃ¼r EINEN Step
# =====================================================================

def update_screenshots(folder_path):
    """Aktualisiert die Screenshot-Liste in einem Step-Ordner"""
    screenshots = os.path.join(folder_path, "screenshots")
    thumbs = os.path.join(folder_path, "thumbnails")

    if not os.path.exists(screenshots):
        log(f"[SKIP] Kein screenshot-Ordner in {folder_path}")
        return "- Noch keine Screenshots"

    if PIL_AVAILABLE and not os.path.exists(thumbs):
        os.makedirs(thumbs)
        log(f"[CREATE] thumbnails/ erstellt in {folder_path}")

    # Alle Bilder finden
    files = []
    for f in os.listdir(screenshots):
        ext = os.path.splitext(f)[1].lower()
        if ext in {".png", ".jpg", ".jpeg", ".gif"}:
            full = os.path.join(screenshots, f)
            mtime = os.path.getmtime(full)
            files.append((f, mtime))

    if not files:
        return "- Noch keine Screenshots"

    # Neueste zuerst
    files.sort(key=lambda x: x[1], reverse=True)

    # Thumbnails erzeugen & Markdown erstellen
    md_pages = []
    current_page = []

    for fname, _ in files:
        input_path = os.path.join(screenshots, fname)
        thumb_path = os.path.join(thumbs, fname) if PIL_AVAILABLE else None

        # Thumbnail erzeugen falls nicht vorhanden
        if PIL_AVAILABLE and thumb_path and not os.path.exists(thumb_path):
            create_thumbnail(input_path, thumb_path)

        # Markdown Eintrag
        if PIL_AVAILABLE and thumb_path and os.path.exists(thumb_path):
            md_line = f'<a href="screenshots/{fname}"><img src="thumbnails/{fname}" width="{THUMB_WIDTH}" style="border: 3px solid #333; border-radius: 8px; display: block;"></a>'
        else:
            md_line = f"- [{fname}](screenshots/{fname})"

        current_page.append(md_line)

        # Pagination
        if len(current_page) == PER_PAGE:
            md_pages.append(current_page)
            current_page = []

    if current_page:
        md_pages.append(current_page)

    # Markdown zusammenbauen
    md_final = []

    if len(md_pages) == 1:
        md_final.extend(md_pages[0])
    else:
        for current, page in enumerate(md_pages):
            nav_links = []
            for i in range(len(md_pages)):
                if i != current:
                    nav_links.append(f"[Seite {i+1}](#seite-{i+1})")
            
            md_final.append(f"### Seite {current+1}")
            md_final.append("")
            md_final.append("**Gehe zu:** " + " | ".join(nav_links))
            md_final.append("")
            md_final.extend(page)
            md_final.append("")

    return "\n".join(md_final)

# =====================================================================
# Update ALLE Steps
# =====================================================================

def update_all():
    """Aktualisiert alle Step-Ordner"""
    updated = 0

    if not os.path.exists(STEPS_DIR):
        print(f"âŒ Ordner nicht gefunden: {STEPS_DIR}")
        log(f"[ERROR] STEPS_DIR nicht gefunden: {STEPS_DIR}")
        return

    step_folders = [f for f in os.listdir(STEPS_DIR) if f.startswith("step_")]
    if not step_folders:
        print("â„¹ï¸  Keine step_XX Ordner gefunden. Nichts zu aktualisieren.")
        log("[SKIP] Keine Step-Ordner vorhanden.")
        return

    for folder in step_folders:
        folder_path = os.path.join(STEPS_DIR, folder)
        readme = os.path.join(folder_path, "README.md")

        if not os.path.exists(readme):
            log(f"[SKIP] Kein README in {folder_path}")
            continue

        screenshots = os.path.join(folder_path, "screenshots")
        if not os.path.exists(screenshots) or not os.listdir(screenshots):
            md = "- Noch keine Screenshots"
        else:
            md = update_screenshots(folder_path)
            if md is None:
                continue

        # README ersetzen
        with open(readme, "r", encoding="utf-8") as f:
            content = f.read()

        if "## ğŸ“¸ Screenshots" in content:
            pre, _ = content.split("## ğŸ“¸ Screenshots", 1)
            new_content = pre + "## ğŸ“¸ Screenshots\n\n" + md

            with open(readme, "w", encoding="utf-8") as f:
                f.write(new_content)

            updated += 1
            log(f"[UPDATE] README aktualisiert in {folder}")

    print(f"âœ” UPDATE abgeschlossen. {updated} Ordner aktualisiert.")
    log(f"[DONE] Update abgeschlossen: {updated}")

# =====================================================================
# Hilfsfunktionen
# =====================================================================

def normalize_title(title: str) -> str:
    """Konvertiert Titel in saubere kebab-case Ordnernamen."""
    title = title.lower().strip()
    title = re.sub(r"Ã¤", "ae", title)
    title = re.sub(r"Ã¶", "oe", title)
    title = re.sub(r"Ã¼", "ue", title)
    title = re.sub(r"ÃŸ", "ss", title)
    title = re.sub(r"[^a-z0-9]+", "-", title)
    title = re.sub(r"-+", "-", title)
    return title.strip("-")

def get_next_step_number():
    """Findet die hÃ¶chste step_XX und gibt +1 zurÃ¼ck."""
    if not os.path.exists(STEPS_DIR):
        return "01"
    max_step = 0
    for folder in os.listdir(STEPS_DIR):
        if folder.startswith("step_"):
            parts = folder.split("_")
            if len(parts) > 1 and parts[1].isdigit():
                num = int(parts[1])
                if num > max_step:
                    max_step = num
    return f"{max_step + 1:02d}"

# =====================================================================
# INIT: Neuen Step anlegen
# =====================================================================

def ensure_gitignore():
    """Erstellt .gitignore im Root-Verzeichnis (einmalig)"""
    gitignore_path = os.path.join(ROOT_DIR, ".gitignore")
    
    if not os.path.exists(gitignore_path):
        with open(gitignore_path, "w", encoding="utf-8") as f:
            f.write(GITIGNORE_TEMPLATE)
        log("[CREATE] .gitignore erstellt im Root")
        print("âœ… .gitignore wurde im cpp_mastery/ Root erstellt")

def init_step(step, title):
    """Erstellt einen neuen Step-Ordner mit kompletter Struktur"""
    
    # Stelle sicher, dass .gitignore existiert (einmalig)
    ensure_gitignore()
    
    if not os.path.exists(STEPS_DIR):
        os.makedirs(STEPS_DIR)
        log(f"[CREATE] steps/ Ordner erstellt: {STEPS_DIR}")

    title_norm = normalize_title(title)
    folder = os.path.join(STEPS_DIR, f"step_{step}_{title_norm}")

    if os.path.exists(folder):
        print(f"âš ï¸  Step {step} existiert bereits: {folder}")
        return

    # Ordnerstruktur erstellen
    os.makedirs(folder)
    os.makedirs(os.path.join(folder, "src"), exist_ok=True)
    os.makedirs(os.path.join(folder, "include"), exist_ok=True)  # Header-Ordner
    os.makedirs(os.path.join(folder, "build"), exist_ok=True)
    os.makedirs(os.path.join(folder, "screenshots"), exist_ok=True)
    
    if PIL_AVAILABLE:
        os.makedirs(os.path.join(folder, "thumbnails"), exist_ok=True)

    # Optional: include/ Ordner
    # os.makedirs(os.path.join(folder, "include"), exist_ok=True)

    # README.md
    readme = os.path.join(folder, "README.md")
    with open(readme, "w", encoding="utf-8") as f:
        f.write(README_TEMPLATE.format(
            step=step,
            title=title,
            example_code="// Dein Beispielcode hier",
            debug_code="// Debug-Beispiel hier",
            screenshots_markdown="- Noch keine Screenshots"
        ))

    # CMakeLists.txt
    cmake = os.path.join(folder, "CMakeLists.txt")
    with open(cmake, "w", encoding="utf-8") as f:
        f.write(CMAKELISTS_TEMPLATE.format(
            step=step,
            title=title,
            title_norm=title_norm
        ))

    # CMakePresets.json
    import json
    presets_file = os.path.join(folder, "CMakePresets.json")
    with open(presets_file, "w", encoding="utf-8") as f:
        json.dump(get_cmake_presets(step, title_norm), f, indent=4)

    # .vscode/launch.json erzeugen
    vscode_dir = os.path.join(folder, ".vscode")
    os.makedirs(vscode_dir, exist_ok=True)

    launch_file = os.path.join(vscode_dir, "launch.json")
    with open(launch_file, "w", encoding="utf-8") as f:
        f.write(LAUNCH_JSON_TEMPLATE)

    # src/main.cpp
    main_cpp = os.path.join(folder, "src", "main.cpp")
    with open(main_cpp, "w", encoding="utf-8") as f:
        f.write(MAIN_CPP_TEMPLATE.format(
            step=step,
            title=title
        ))

    # .gitkeep fÃ¼r build/
    gitkeep = os.path.join(folder, "build", ".gitkeep")
    with open(gitkeep, "w") as f:
        pass

    print(f"âœ… INIT abgeschlossen")
    print(f"ğŸ“ Ordner: step_{step}_{title_norm}/")
    print(f"ğŸ“ Bereit zum Coden in src/main.cpp")
    print(f"ğŸ”¨ Build mit: F7 in VS Code oder 'cmake --preset default && cmake --build build'")
    log(f"[INIT] Step erstellt: step_{step}_{title_norm}")

# =====================================================================
# MAIN
# =====================================================================

if __name__ == "__main__":
    args = sys.argv[1:]
    
    # UPDATE MODE (keine Argumente)
    if len(args) == 0:
        update_all()
        sys.exit()
    
    # PrÃ¼fe ob erstes Argument eine Step-Nummer ist (2 Ziffern)
    first_is_step = len(args[0]) == 2 and args[0].isdigit()
    
    if first_is_step:
        # Format: Step + Titel
        step = args[0]
        title = " ".join(args[1:]) if len(args) > 1 else "untitled"
    else:
        # Format: Nur Titel (Auto-Step)
        step = get_next_step_number()
        title = " ".join(args)
    
    init_step(step, title)